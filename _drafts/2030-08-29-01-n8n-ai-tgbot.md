---
layout: post
# author: "Epy Blog"
title: "n8n workflow 1 - Telegram Bot (Work in Progress..)"
tags:
  - n8n Workflows
usemathjax:     true
more_updates_card: false
giscus_term: n8n-tg-bot-1
yt_community_link: false
excerpt_separator: <!--more-->
---

# Step 1 — Bot + Keys sanity check

## 1) Create the Telegram bot (or reuse yours)

* In Telegram, open **@BotFather** → `/newbot`
* Give it a name of your choice - No Spaces 
* Give it a **username** of your choice but it should end with *bot* (e.g., `@epyaibot`)
* Copy the **Bot Token** (we’ll use it in n8n) <!--more-->

**Important for groups:**
Run `/setprivacy` in **@BotFather** → choose your bot (eg. type `@epyaibot`) → **Disable** privacy.
*Reason:* with privacy enabled, the bot will only receive messages that either start with the '/' symbol or mention the bot by username. If we disable it, then the bot will receive all messages that people send to groups.

## 2) Get your OpenRouter API key

* Create/get key from OpenRouter → copy the **API key**

## 3) Set environment variables in WSL

In your WSL terminal:

```bash
export TELEGRAM_BOT_TOKEN="123456:ABCDEF-your-bot-token"
export OPENROUTER_API_KEY="sk-or-xxxxxxxx"

# (optional) make them permanent
echo 'export TELEGRAM_BOT_TOKEN="123456:ABCDEF-your-bot-token"' >> ~/.bashrc
echo 'export OPENROUTER_API_KEY="sk-or-xxxxxxxx"' >> ~/.bashrc
source ~/.bashrc
```

## 4) Telegram Bot Token Check in Terminal (WSL/Linux)

* Confirm if the telegram bot token is set properly
  ```bash
  echo $TELEGRAM_BOT_TOKEN
  ```
  * Expected: your full token string (e.g. `1234567890:AAEoXXXXX-YYYYYYYYY`).
  * If blank → the variable isn’t set → re-run `export`.

* Test the bot info API (type the below in wsl terminal)

  ```bash
  curl -s https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/getMe
  ```
* Expected success (token valid):

  ```json
  {"ok":true,"result":{"id":7238073603,"is_bot":true,"first_name":"epyaibot","username":"epyaibot",...}}
  ```
* **Error examples:**
  * `{"ok":false,"error_code":404,"description":"Not Found"}` → token string malformed (missing colon or truncated).
  * `{"ok":false,"error_code":401,"description":"Unauthorized"}` → token invalid (wrong bot token).
  * Blank output → env var not set in this shell.

* (Optional) Pretty-print JSON with `jq` - If you want nicer formatting:

  ```bash
  sudo apt update && sudo apt install -y jq
  curl -s https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/getMe | jq
  ```
  * Output becomes:

    ```json
    {
      "ok": true,
      "result": {
        "id": 7238073603,
        "is_bot": true,
        "first_name": "epyaibot",
        "username": "epyaibot",
        ...
      }
    }
    ```

* (Optional) Make token persistent (so you don’t re-export each time)
  * Add this line to `~/.bashrc`:

    ```bash
    export TELEGRAM_BOT_TOKEN=1234567890:AAEoXXXXX-YYYYYYYYYYYY
    ```

  * Then reload:

    ```bash
    source ~/.bashrc
    ```

  * Now every new WSL session will have it ready.

* End Result - When `curl .../getMe` returns `"ok":true` with your bot info, your Telegram token is verified and ready to use in n8n.


## 5) OpenRouter API Key Check in Terminal (WSL/Linux)

* Confirm it’s set
  ```bash
  echo $OPENROUTER_API_KEY
  ```
  * Expected: your full key string.
  * If blank → the variable isn’t set → re-run `export`.

* Test the API (list models)

  ```bash
  curl -s https://openrouter.ai/api/v1/models \
    -H "Authorization: Bearer $OPENROUTER_API_KEY"
  ```

  You’re right—my “Expected success” sample was too generic. Here’s a **corrected description + example** that matches what OpenRouter actually returns today.

* Expected success (valid key) - OpenRouter returns a JSON object with a top-level `"data"` array.
  Each element is a **model descriptor**. Fields can evolve, but you’ll typically see:

  * `id` (required) – canonical model id
  * `canonical_slug` – stable slug
  * `name` – human-readable name
  * `created` – epoch timestamp
  * `description` – long text
  * `context_length` – max tokens
  * `architecture` – e.g., `{ "modality": "text" }` (may include more)
  * (sometimes) `pricing`, `top_provider`, `meta`, etc.

  **Example (truncated):**

  ```json
  {
    "data": [
      {
        "id": "qwen/qwen3-30b-a3b-thinking-2507",
        "canonical_slug": "qwen/qwen3-30b-a3b-thinking-2507",
        "name": "Qwen: Qwen3 30B A3B Thinking 2507",
        "created": 1756399192,
        "description": "Qwen3-30B-A3B-Thinking-2507 is a 30B parameter ...",
        "context_length": 262144,
        "architecture": { "modality": "text" }
        /* ...additional fields may appear... */
      }
    ]
  }
  ```
* Error examples (updated)

  * **Invalid/missing key:**
    `{"error":"Unauthorized"}` with HTTP **401**
  * **Bad header format:**
    `{"error":"Forbidden"}` with HTTP **403** (e.g., no `Authorization: Bearer <key>`)
  * **Rate limited:**
    `{"error":"Too Many Requests"}` with HTTP **429**
  * **Env var not set:** empty/blank output (your shell expands to nothing)

* (Schema may add fields over time; the key check is simply that you get a JSON with a `"data"` array and at least one item with an `"id"`.)*

* (Optional) Pretty-print JSON with `jq`

  * If you installed `jq`:

    ```bash
    curl -s https://openrouter.ai/api/v1/models \
      -H "Authorization: Bearer $OPENROUTER_API_KEY" | jq
    ```

  * This formats it into readable JSON.

* Make key persistent

  * Add this line to `~/.bashrc`:

    ```bash
    export OPENROUTER_API_KEY=sk-or-xxxxxxxxxxxxxxxxxxxxxxxx
  ```

  * Reload:

    ```bash
    source ~/.bashrc
    ```

  * Now it’ll be available in every new WSL session.

---

* End Result - When `curl .../models` returns a JSON with a `"data": [...]` list, your OpenRouter API key is verified and ready to use in n8n.